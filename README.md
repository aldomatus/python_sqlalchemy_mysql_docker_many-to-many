<!--
*** Thanks for checking out the Best-README-Template. If you have a suggestion
*** that would make this better, please fork the repo and create a pull request
*** or simply open an issue with the tag "enhancement".
*** Thanks again! Now go create something AMAZING! :D
-->

<!-- PROJECT LOGO -->
<br />
<p align="center">
  <a href="https://github.com/othneildrew/Best-README-Template">
    <img src="https://i.imgur.com/yu0eHMd.png" alt="Header" >
  </a>
   <div align="center">
   <a href="https://www.facebook.com/aldo.matusmartinez" ><img src="https://github.com/edent/SuperTinyIcons/blob/master/images/svg/facebook.svg" title="Facebook" width="60"  margin="30px"/></a><a href="https://github.com/aldomatus/" ><img src="https://github.com/edent/SuperTinyIcons/blob/master/images/svg/github.svg" title="Github" width="60"/></a><a href="https://www.instagram.com/aldomatus1/" ><img src="https://github.com/edent/SuperTinyIcons/blob/master/images/svg/instagram.svg" title="Instagram" width="60"  /></a><a href="https://www.linkedin.com/in/aldomatus/" ><img src="https://github.com/edent/SuperTinyIcons/blob/master/images/svg/linkedin.svg" title="Linkedin" width="60"  /></a>

  </div>
  <h1 align="center">THIS PROJECT WAS MADE TO LEARN TO USE MANY-TO-MANY RELATIONSHIPS WITH THE SQLALCHEMY ORM </h1>
  <h3 align="center">Learn REST API with Flask, Mysql and Docker</h3>
</p>



<!-- TABLE OF CONTENTS -->
<details open="open">
  <summary>Table of Contents</summary>
  <ol>
    <li>
      <a href="#about-the-project">About The Project</a>
      <ul>
        <li><a href="#built-with">Built With</a></li>
      </ul>
    </li>
    <li>
      <a href="#getting-started">Getting Started</a>
      <ul>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#installation">Installation</a></li>
      </ul>
    </li>
    <li><a href="#usage">Usage</a></li>
    <li><a href="#roadmap">Roadmap</a></li>
    <li><a href="#contributing">Contributing</a></li>
    <li><a href="#license">License</a></li>
    <li><a href="#contact">Contact</a></li>
  </ol>
</details>



<!-- ABOUT THE PROJECT -->
## About The Project
At the beginning of my career I had problems like these and today I share what I know to make your path in software development easier. In this installment I show you how to use the orm called flask-sqlalchemy with many to many tables in which we have a bridge table. If you want to know about bridge tables: [Bridge Tables](https://www.ibm.com/docs/en/cognos-analytics/11.1.0?topic=relationships-bridge-tables)

## Purpose of the project ğŸš€
This project is made with the intention of teaching how to use Docker with the backend technologies Flask and Mysql in the project we are going to take into account the following points:
* Create a database with normalized tables via bridge tables
* Make a many to many relationship between tables.
* handling many to many relationships with the flask sqlalchemy ORM.
* Create the dockerfile that will have the necessary instructions to create a Python image that will later be converted into a single application.
* Docker Compose allows you through YAML files to instruct the Docker Engine to perform tasks, programmatically. Here we will install the mysql image, declare the environment variables for both mysql and Flask, and also declare the volumes.
* We will add the list of requirements in a requirements.txt file that will be executed automatically within the Dockerfile

### Built With

This section should list any major frameworks that you built your project using. Leave any add-ons/plugins for the acknowledgements section. Here are a few examples.
* [Flask](https://flask.palletsprojects.com/en/2.0.x/)
* [Mysql](https://www.mysql.com/)
* [Docker](https://www.docker.com/)
* [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)

### Libraries

#### SQLAlchemy (Offers an ORM along with a Core)
The Python SQL Toolkit and Object Relational Mapper
SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL.

#### Flask-Marshmallow (Serializer)
Flask-Marshmallow is a thin integration layer for Flask (a Python web framework) and marshmallow (an object serialization/deserialization library) that adds additional features to marshmallow, including URL and Hyperlinks fields for HATEOAS-ready APIs. It also (optionally) integrates with Flask-SQLAlchemy.

#### Flask-SQLAlchemy 
Flask-SQLAlchemy is an extension for Flask that adds support for SQLAlchemy to your application. It aims to simplify using SQLAlchemy with Flask by providing useful defaults and extra helpers that make it easier to accomplish common tasks.

#### Flask JWT
JSON Web Tokens (or JWTs) provide a means of transmitting information from the client to the server in a stateless, secure way.
On the server, JWTs are generated by signing user information via a secret key, which are then securely stored on the client. This form of auth works well with modern, single page applications. 

<!-- GETTING STARTED -->
## Getting Started
### To check your rest api
#### Insomnia

With their streamlined API client, you can quickly and easily send REST, SOAP, GraphQL, and GRPC requests directly within Insomnia.
Link to visit insomnia website: - [Link](https://insomnia.rest/download)
<div align="center">
 <img src=https://seeklogo.com/images/I/insomnia-logo-A35E09EB19-seeklogo.com.png width="150" alt="Header" >
  </div>


#### Postman
Postman is a collaboration platform for API development. Postman's features simplify each step of building an API and streamline collaboration so you can create better APIsâ€”faster.
Link to visit postman website: - [Link](https://www.postman.com/downloads/)
<div align="center">
 <img src=https://seeklogo.com/images/P/postman-logo-F43375A2EB-seeklogo.com.png width="150" alt="Header" >
</div>

### Prerequisites

For this project you need to have Docker and Docker compose installed


<ol>
<li>Link to install Docker engine:</li>
<a href="https://docs.docker.com/engine/install/ubuntu/">Linux</a>
<a href="https://docs.docker.com/engine/install/">  -  Windows or Mac</a>

<li>After installing docker engine install docker compose</li>
<a href="https://docs.docker.com/compose/install/">Linux Windows Mac</a>
</li>

### knowing our data
To start, the project is a kind of YouTube in which we are going to have users and channels, among them we can make the relationship many to many because many users are subscribed to many channels and many channels have many users. We will have three tables: users, channels and a third that will inform us of the subscriptions of each user. In the third table we will join the primary keys of each table (users and channels)
<div align="center">
 <img src=https://static.coodex.es/wp-content/uploads/2014/10/usuarios-youtube-espana-1.jpg width=250 alt="Header" >
</div>

### Entity relationship model
For the construction of the database, the relationship entity model was made with which the relationships between each table were deduced. 
<div align="center">
 <img src=https://i.imgur.com/osfDbYs.png alt="Header" >
</div>


### Installation ğŸ–¥

1. To obtain my repository you must create a folder in a desired directory and within this folder open a terminal or use cmd in the case of windows.
2. Clone the repo
   ```
   git remote add origin git@github.com:aldomatus/python_sqlalchemy_mysql_docker_many-to-many
   
   ```
3. Make the pull request from a branch called main
   ```
   git pull origin main --allow-unrelated-histories
   
   ```
  > git branch -m main is the command to rename the branch
 

4. In the folder where docker-compose.yml is located, open a terminal (the same address where you ran the previous line) and write the following command to build the image.
   ```
   docker-compose build
   ```
5. Once the previous execution is finished, you must run the services made in the build.
   ```
   docker-compose up
   ```
10. Now we are ready to work and query from sql alchemy

12. If all goes well, our application should already be executing the main.py file with python using the mysql database, now we just have to check by entering the following link in our browser:

   ```
   http://localhost:5000/
   ```
6. You should have a response like this:
   ```
   {"message": 'Welcome to my API'}
  
   ```

## Description of the files ğŸ’¼ ğŸ³
```python
flask
Flask-SQLAlchemy==2.4.4
SQLAlchemy==1.3.20
pymysql
marshmallow-sqlalchemy
Flask-Migrate==2.5.3
Flask-Script==2.0.6
Flask-Cors==3.0.9
requests==2.25.0
flask-marshmallow
pika==1.1.0
```

### requirements.txt
In our requirements file we write the flask libraries, the connection libraries for msql and with which we are going to manage the SQL data
```python
flask
Flask-SQLAlchemy==2.4.4
SQLAlchemy==1.3.20
flask-login==0.4.1
pymysql
marshmallow-sqlalchemy
flask-marshmallow
```

### Dockerfile ğŸ³
Create the dockerfile that will have the necessary instructions to create a Python image that will later be converted into a single application.
- we add our environment variables from flask
- We run the requirements file so that our libraries are installed
- We expose the port to use which is 5000
- With CMD we start Flask 
```docker
  
FROM python:3.7-alpine
ENV PYTHONUNBUFFERED 1
RUN mkdir /code
WORKDIR /code
ENV FLASK_APP=src/main.py
ENV FLASK_RUN_HOST=0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
EXPOSE 5000
COPY . .
CMD ["flask", "run"]
```


### Docker-compose ğŸ³ğŸ³ğŸ³
Docker Compose allows you through YAML files to instruct the Docker Engine to perform tasks, programmatically. Here we will install the mysql image, declare the environment variables for both mysql and Flask, and also declare the volumes.

  - we download the image
  - volumes
  - Environment Variables
  - ports


```script
version: "3.8"

services:
  db:
    image: mysql:5.7
    volumes:
      - .dbdata:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: youtube 
      MYSQL_PASSWORD: root
    ports: 
      - 3308:3306

  backend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "5000:5000"  
    
    volumes:
      - .:/code
    depends_on:
      - db

    env_file: .env
```

### .env file ğŸŒ
This file contains our environment variables that will be read by the dockerfile. 

```
FLASK_DEBUG=True
FLASK_APP=src/main.py
FLASK_RUN_HOST=0.0.0.0
ALLOWED_HOSTS=127.0.0.1,localhost
```
### Project structure 
To make the modularization of our project we can make use of blueprints 

```script
.
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ ERM.drawio
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”œâ”€â”€ channels
â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”œâ”€â”€ __pycache__
â”‚   â”‚   â”œâ”€â”€ subs
â”‚   â”‚   â””â”€â”€ users
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ __pycache__   
â””â”€â”€ venv
```
#### Use of Blueprints
Blueprints: they are a series of routes that we can integrate into our application but in another directory that is, it will allow me to modulate the application into small applications that do specific things such as authentication or the welcome part, or if we have a task dashboard for Example we would also create a blueprint for the specific tasks and it is easier to handle.

- The blue squares represent folders and the yellow figures are the files

<p align="center">
  <a href="https://github.com/aldomatus/python_rest_api_mysql_docker">
    <img src="https://raw.githubusercontent.com/innacroft/Apptask/master/app/static/images/estructura_carpetas.PNG" alt="Header" >
  </a>
</p>

<!-- USAGE EXAMPLES -->
## Usage
<!-- EXPLAIN CODE -->
## Description of the MOdels code
### __init__.py
First we create a file inside our app folder which will be called __init__.py this file indicates that the folder is a module, therefore here we can initialize our app

```python
from flask import Flask
from .config import Config

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    return app

```
### config.py
We create a file called config inside our app folder where we configure the connection to the database
```python
class Config():
    #-------------------database connection------------
    SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:root@db/youtube'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = 'youtube'

```
### main.py
In our main.py that is located in the src folder, we make an instance of our app with create_app which we import from src.app, then we import our blueprints and register them, finally we make an instance of SQLAlchemy and Marshmallow to handle our data API and database.
```python
# Flask libraries
from src.app import create_app
from flask import Flask, blueprints, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow

app = create_app()

# ------------Registro de los blueprints----
from src.app.users.users import users
from src.app.channels.channels import channels
from src.app.subs.subs import subs
from src.app.home.home import home

app.register_blueprint(users)
app.register_blueprint(channels)
app.register_blueprint(subs)
app.register_blueprint(home)

#--------Instances SQLALchemy and Marshmallow---------
db = SQLAlchemy(app)
ma = Marshmallow(app)

```


### Models.py ğŸ‘¨ â–¶ï¸ 
Inside our app folder we have a file called models.py which contains the models to handle the database tables, the models will help us to create the tables, insert, modify and delete data.
```python
from src.main import db, ma

#---------Models--------------------------

subs = db.Table('subs',
    db.Column('user_id', db.Integer, db.ForeignKey('users.user_id')),
    db.Column('channel_id', db.Integer, db.ForeignKey('channels.channel_id'))
)
#------------User Model-----------------
class User(db.Model):
    __tablename__= 'users'
    user_id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20))
    subscriptions = db.relationship('Channel', secondary=subs, backref=db.backref('subscribers', lazy='dynamic'))

    def __init__(self, name):
        self.name = name

class UserSchema(ma.Schema):
    class Meta:
        fields = ("user_id", "name")

user_schema = UserSchema()
users_schema = UserSchema(many = True)

#------------Channel Model-----------------
class Channel(db.Model):
    __tablename__= 'channels'
    channel_id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20))

    def __init__(self, name):
        self.name = name

class ChannelSchema(ma.Schema):
    class Meta:
        fields = ("channel_id", "name")

channel_schema = ChannelSchema()
channels_schema = ChannelSchema(many = True)

db.create_all()

```

#### **User model** ğŸ‘¨
Our first model is the user one which contains a column called user_id, in this column we will save our primary keys, another column is name where we will save the names of the users, in the model you can see a variable called subscriptions, it will not be converted in a column of the users table, it will only serve to maintain the relationship that we must have with channel when a user signs up for a channel.

```python
#------------User Model-----------------
class User(db.Model):
    __tablename__= 'users'
    user_id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20))
    subscriptions = db.relationship('Channel', secondary=subs, backref=db.backref('subscribers', lazy='dynamic'))

    def __init__(self, name):
        self.name = name

class UserSchema(ma.Schema):
    class Meta:
        fields = ("user_id", "name")

user_schema = UserSchema()
users_schema = UserSchema(many = True)
```



#### **Channel model** â–¶ï¸ 
Our channel model contains a column called channel_id, in this column we will store our primary keys, another column is name where we will store the names of the channels. Then we have the ChannelSchema class, which is responsible for outlining the models to work serialization with the API.
```python
#------------Channel Model-----------------
class Channel(db.Model):
    __tablename__= 'channels'
    channel_id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20))

    def __init__(self, name):
        self.name = name

class ChannelSchema(ma.Schema):
    class Meta:
        fields = ("channel_id", "name")

channel_schema = ChannelSchema()
channels_schema = ChannelSchema(many = True)
```

#### **Bridge Table** ğŸŒ‰ 

This is our bridge table does not need a class, in this class we will save the relationships between users and channels, joining a user_id with a channel_id, in this way we will know which users are subscribed with which channels

```python
subs = db.Table('subs',
    db.Column('user_id', db.Integer, db.ForeignKey('users.user_id')),
    db.Column('channel_id', db.Integer, db.ForeignKey('channels.channel_id'))
)

```
#### This is how our tables will look
```sql
Database changed
mysql> SELECT * FROM users;
+---------+------+
| user_id | name |
+---------+------+
|       1 | Aldo |
+---------+------+
1 row in set (0.00 sec)

mysql> SELECT * FROM channels;
+------------+-------------+
| channel_id | name        |
+------------+-------------+
|          1 | The Beatles |
+------------+-------------+
1 row in set (0.00 sec)

mysql> SELECT * FROM subs;
+---------+------------+
| user_id | channel_id |
+---------+------------+
|       1 |          1 |
+---------+------------+
1 row in set (0.00 sec)

```
### Add a subscription ğŸ””
To create the subscription API we have to make use of the post method where we will receive the user_id which is the primary key of the user and the channel_id which is the primary key of the channel.
#### Save our subscriptions 
The most important are the following lines because with them we are going to save the subscription records in our database :
```python
        channel.subscribers.append(user)
        db.session.commit()

        return jsonify({'message': 'You are subscribed!'})
```

## REST API code ğŸ‘¨â€ğŸ’»

### users API ğŸ‘¨
Our user API receives the user's name through a post, outlines it with marshmallow and saves it in the database.
I have a fake log file for testing ğŸ§ªğŸ§ªğŸ§ª
```python
{
  "name": "Aldo"
}
```
<div align="center">
 <img src=https://i.imgur.com/mmzj6vB.png  alt="Header" >
</div>


### channel API â–¶ï¸ 
Our user API receives the channel's name through a post, outlines it with marshmallow and saves it in the database.
I have a fake log file for testing ğŸ§ªğŸ§ªğŸ§ª
```python
{
  "name": "The Beatles"
}
```
<div align="center">
 <img src=https://i.imgur.com/V3emvuY.png  alt="Header" >
</div>


#### All API subs code ğŸ””
Our user API receives the user's id (user_id) and channel's id (channel_id) through a post, outlines it with marshmallow and saves it in the database.
I have a fake log file for testing ğŸ§ªğŸ§ªğŸ§ª
```python
{
  "user_id": "1",
  "channel_id": "1"
}
```

```python
from flask import request, jsonify, Blueprint

subs = Blueprint('subs', __name__)

@subs.route('/subs', methods=['GET'])
def users_regards():
    return jsonify({'message': 'Welcome!'})

@subs.route('/sub', methods=['GET','POST'])
def create_sub():
    from src.app.models import Channel
    from src.app.models import User
    from src.main import db

    # Receive requests
    if request.method == 'POST':
        user_id = request.json['user_id']
        channel_id = request.json['channel_id']

        user = User.query.filter_by(user_id=user_id).first()
        channel = Channel.query.filter_by(channel_id=channel_id).first()

        channel.subscribers.append(user)
        db.session.commit()

        return jsonify({'message': 'You are subscribed!'})
```
<div align="center">
 <img src=https://i.imgur.com/1SVm7lz.png  alt="Header" >
</div>


<!-- ROADMAP -->
## Roadmap

See the [open issues](https://github.com/aldomatus/flask_rest_api/issues) for a list of proposed features (and known issues).

<!-- CONTRIBUTING -->
## Contributing

Contributions are what make the open source community such an amazing place to be learn, inspire, and create. Any contributions you make are **greatly appreciated**.

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request



<!-- LICENSE -->
## License

Distributed under the MIT License. See `LICENSE` for more information.



<!-- CONTACT -->
## Contact

Aldo Matus - [Linkedin](https://www.linkedin.com/in/aldomatus/) [Facebook](https://www.facebook.com/aldo.matusmartinez/)

Project Link: [Repository](https://github.com/aldomatus/flask_rest_api/)






